#!/usr/bin/env perl

use warnings;
use strict;
use Data::Dumper;
use Time::Local;
use DBI;
use FindBin qw($Bin $Script);

use lib "$Bin/../lib";
use Outspam qw (read_config);

my $conf = {
  'maillog' => '',
  'domain' => '',
  'bookmark'=> '',
  'db' => '',
  'dbhost' => '',
  'dbuser'=> '',
  'dbpassword' => '' 
 };

my $config_file = "$Bin/../etc/outmaillog.conf";
read_config($config_file,$conf);

my $conn = DBI->connect("DBI:mysql:$conf->{'db'}:$conf->{'dbhost'}", $conf->{'dbuser'}, $conf->{'dbpassword'});
die "Connection to database failed\n" unless $conn;
$conn->prepare("SET SESSION sql_mode=\'\'")->execute();

my $from_filter = '.+\@' . $conf->{'domain'};
my $to_filter = '.+\@(?!' . $conf->{'domain'} . ')[^>]+';

my $startime = time;
my $yearnow = (localtime(time))[5];
my $yearlog = $yearnow+1;


my $pre_first_line;
my $pre_last_msg;
my $cur_first_line;
my $cur_last_msg;

($pre_first_line, $pre_last_msg) = rbookmark();

my $f;
open $f, "<$conf->{'maillog'}" or die "$conf->{'maillog'} $!";
$cur_first_line = <$f>;
unless (defined($pre_first_line) && $pre_first_line eq $cur_first_line) {
    undef $pre_last_msg;
}    
seek($f,0,0);

my %mail;
my @msgid;

while ( <$f> ) {
    next unless / sm-mta\[\d+\]: /;

    if ( $_ =~ /^\w+ \d+ \S+ \S+ \S+ (\S+): from=<($from_filter)>, size=(\d+), class=\S+, nrcpts=(\d+), .* relay=[^\[]*\[([\d\.]+)\]/i ) {
       my $msg = $1;
       if (defined $pre_last_msg) {
          undef($pre_last_msg) if $msg eq $pre_last_msg;
          next; 
       }
       $mail{$msg} = {'sndr'=>lc $2, 'size'=>$3, 'nrcpts'=>$4, 'relay'=>$5 };
    }    
    elsif ( $_ =~ /^(\w+) (\d+) (\S+) \S+ \S+ (\S+): to=<($to_filter)>, .* stat=(.*)/i ) {
       my $msg = $4;
       next unless $mail{$msg};
       $mail{$msg}->{'time'}=date2sec($3,$2,$1);
       $mail{$msg}->{'rcpt'}=lc $5;
       $mail{$msg}->{'stat'}=stat_simplify($6);
       $mail{$msg}->{'stat'} = "Sent" if $mail{$msg}->{'stat'} =~ /^Sent /;
       $cur_last_msg = $msg;
       #       print "$msg ",Dumper $mail{$msg};
    }    
}
close $f;

exit 0 unless $cur_last_msg;

foreach my $k (sort keys(%mail)) {
   next unless $mail{$k}->{'rcpt'};
   #print "$k ",Dumper $mail{$k};
   my $query_str = mk_ins_query($k,$mail{$k});
   if ( $query_str ) {
      my $query = $conn->prepare($query_str);
      $query->execute() or query_err($conn,$query_str); 
   }   
}    

wbookmark($cur_first_line,$cur_last_msg);

# ====================================================

sub stat_simplify {
    my $stat = shift;
    if ($stat =~ /^Sent /) { $stat = "sent"; }
    #    elsif ($stat =~ /^Deferred/) { $stat = "defered"; }
    return $stat;
}    

sub mk_ins_query {
    (my $msg, my $h) = @_;
    my $q = "";
    #  print Dumper(%$h);
    foreach my $k (keys (%$h)) {
        $q .= ", " if $q;
        if ( $k eq 'stat' ) {
           $q .= "$k=QUOTE(\'$h->{$k}\')"
        }
        else { $q .= "$k=\'$h->{$k}\'"; }
    }
    $q = "insert ignore maillog set msg=\'$msg\', ".$q if $q;
    return $q;
}    

sub query_err {
    (my $conn, my $q ) = @_;
    print "Error: query \"". $q ."\" failed\n";
    die $conn->errstr;
}    

sub date2sec {
    (my $smh, my $day, my $mon) = @_;
    my $tm = timelocal (reverse (split(/:/,shift)), shift, shift, $yearlog);
    if ( $tm gt $startime ) {
      --$yearlog;
      $tm = date2sec($smh,$day,$mon);
    }
    return $tm;
}

sub rbookmark {

  my $log_first_line;
  my $log_last_msg;

  if ( -f $conf->{'bookmark'} ) { 
     open(my $b, '<', $conf->{'bookmark'}) or die "$conf->{'bookmark'} $!";
     $log_first_line = readline $b;
     $log_last_msg = readline $b;
     close $b;
  }
  undef $log_first_line unless defined $log_last_msg;
  undef $log_last_msg unless defined $log_first_line;
  return ($log_first_line, $log_last_msg);
}

sub wbookmark {
   (my $log_first_line, my $log_last_msg) = @_;
   open($b, '>', $conf->{'bookmark'}) or die "write $conf->{'bookmark'} $!";
   print $b $log_first_line if defined $log_first_line;
   print $b $log_last_msg if defined $log_last_msg;
   close $b;
}    
